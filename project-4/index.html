<!doctype html>
<html>
<head>
  <title>Paint</title>
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link href="./style.css" rel="stylesheet" type="text/css">
</head>
<body>
  <div class="container">
    <nav class="left menu">
      <label>Brush Size</label>
      <input type="number" class="input-control fluid" value="10" onchange="setSize(this)"/>
      
      <hr>
      
      <label>Change Color</label>
      <input type="color" class="input-control fluid" value="#000000" onchange="changeColor(this.value)" id="colorPicker" style="height: 30px"/>
      
      <button class="fluid color-sample button" style="background:#CF000F" onclick="changeColor('#CF000F')">MONZA</button>
      <button class="fluid color-sample button" style="background:#22A7F0" onclick="changeColor('#22A7F0')">PICTON BLUE</button>
      <button class="fluid color-sample button" style="background:#F7CA18" onclick="changeColor('#F7CA18')">RIPE LEMON</button>
      <button class="fluid color-sample button" style="background:#26C281" onclick="changeColor('#26C281')">JUNGLE GREEN</button>
      <button class="fluid color-sample button" style="background:#FFFFFF" onclick="changeColor('#FFFFFF')">WHITE</button>
      <hr>
      
      <input type="button" class="default button fluid" value="clear" onclick="clearCanvas()"/>
      <input type="button" class="default button fluid" value="to PNG" onclick="exportImageToPng()"/>
      
      <div class="button-group">
        <button class="icon button" onclick="javascript:setShape('brush')"><img src="icons/brush.png"></button>
        <button class="icon button" onclick="javascript:setShape('colorPicker')"><img src="icons/picker.png"></button>
        <button class="icon button" onclick="javascript:setShape('line')"><img src="icons/line.png"></button>
        <button class="icon button" onclick="javascript:setShape('rectangle')"><img src="icons/rectangle.png"></button>
        <button class="icon button" onclick="javascript:setShape('rectangle-filled')"><img src="icons/rectangle_filled.png"></button>
        <button class="icon button" onclick="javascript:setShape('triangle')"><img src="icons/triangle.png"></button>
        <button class="icon button" onclick="javascript:setShape('triangle-filled')"><img src="icons/triangle_filled.png"></button>
        <button class="icon button" onclick="javascript:setShape('circle')"><img src="icons/circle.png"></button>
        <button class="icon button" onclick="javascript:setShape('circle-filled')"><img src="icons/circle_filled.png"></button>
      </div>
      
      <p></p>
      
    </nav>
    <div class="wrapper">
      <canvas id="cover"  width="860" height="640"></canvas>
      <canvas id="canvas" width="860" height="640"></canvas>
    </div>
  </div>
  <p> &nbsp;<b>Note:</b> type="color" is not supported in Internet Explorer 11 and earlier versions or Safari 9.1 and earlier versions.</p>
</body>
<script type="text/javascript">

// 실제 그림이 그려지는 캔버스
var realCanvas = document.getElementById('canvas');
var realContext = realCanvas.getContext('2d');
// 인터페이스를 위한 임시 캔버스
var fakeCanvas = document.getElementById('cover');
var fakeContext = fakeCanvas.getContext('2d');

function Point(x, y, rad){
  this.x = x;
  this.y = y;
  this.rad = rad;
  this.color = '#000000';
};

var dragging = false;
var pointQueue = new Array();
var brush = {
  color: '#000000',
  thick: 10,
  opacity: 1.0
};
var drawType = 'brush';
var lastClickPosition = { x:0, y:0 };

var cachedImage = realContext.getImageData(0, 0, 1, 1);

fakeCanvas.addEventListener('mousedown', function(evt){
  lastClickPosition.x = evt.pageX - this.offsetLeft;
  lastClickPosition.y = evt.pageY - this.offsetTop;
  
  if( drawType == 'brush' ){
    pointQueue.push({x: lastClickPosition.x, y: lastClickPosition.y, dragging: false});
  }
  dragging = true;
  
  realContext.clearRect(0, 0, realContext.canvas.width, realContext.canvas.height); // Clears the canvas
  realContext.putImageData(cachedImage, 0, 0);

  fakeCanvas.addEventListener('mousemove', addDrawPoint);
});

fakeCanvas.addEventListener('mouseup', looseFocus);
fakeCanvas.addEventListener('mouseleave', looseFocus);
fakeCanvas.addEventListener('mousemove', function(evt){
  var mouseX = evt.pageX - this.offsetLeft;
  var mouseY = evt.pageY - this.offsetTop;
  var oldStrokeStyle = fakeContext.strokeStyle;
  var oldFillStyle = fakeContext.fillStyle;
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
  if( drawType == 'brush' ) {
    fakeContext.beginPath();
    fakeContext.arc(mouseX, mouseY, brush.thick/2, 0, 2*Math.PI);
    fakeContext.fillStyle = brush.color;
    if(brush.color == '#FFFFFF'){
      fakeContext.strokeStyle = 'rgba(0, 0, 0, .25)';
      fakeContext.stroke();
    }
    fakeContext.fill();
    fakeContext.closePath();
  } else if( drawType == 'rectangle' && dragging ) {
    fakeContext.beginPath();
    fakeContext.rect(lastClickPosition.x, lastClickPosition.y, mouseX - lastClickPosition.x, mouseY - lastClickPosition.y);
    fakeContext.strokeStyle = brush.color;
    fakeContext.stroke();
    fakeContext.closePath();
  } else if( drawType == 'rectangle-filled' && dragging ) {
    fakeContext.beginPath();
    fakeContext.fillStyle = brush.color;
    fakeContext.fillRect(lastClickPosition.x, lastClickPosition.y, mouseX - lastClickPosition.x, mouseY - lastClickPosition.y);
    fakeContext.fill();
    fakeContext.closePath();
  } else if( drawType.substr(0, 'circle'.length) == 'circle' && dragging ) {
    var isOnlyStroke = drawType === 'circle';
    var centerX = lastClickPosition.x;
    var centerY = lastClickPosition.y;
    function distance(width, height){
      return Math.sqrt(width*width + height*height);
    };
    fakeContext.beginPath();
    if(isOnlyStroke) fakeContext.strokeStyle = brush.color;
    else             fakeContext.fillStyle = brush.color;
    fakeContext.arc(lastClickPosition.x, lastClickPosition.y, distance(mouseX - centerX, mouseY - centerY), 0, 2 * Math.PI);
    if(isOnlyStroke) fakeContext.stroke();
    else             fakeContext.fill();
    fakeContext.closePath();
    
    fakeContext.beginPath();
    if(isOnlyStroke) fakeContext.strokeStyle = brush.color;
    else             fakeContext.strokeStyle = 'rgba(255, 255, 255, .5)';
    fakeContext.arc(centerX, centerY, brush.thick/2, 0, 2 * Math.PI);
    fakeContext.fillStyle = brush.color;
    fakeContext.fill();
    fakeContext.closePath();
    fakeContext.beginPath();
    fakeContext.moveTo(centerX, centerY);
    fakeContext.lineTo(mouseX, mouseY);
    // fakeContext.stroke();
    fakeContext.closePath();
  } else if( drawType.substr(0, 'triangle'.length) == 'triangle' && dragging ) {
    var triWidth = mouseX - lastClickPosition.x;
    var isOnlyStroke = drawType === 'triangle';
    var threePoint = [
      {x:lastClickPosition.x + triWidth/2, y:lastClickPosition.y},
      {x:mouseX, y:mouseY},
      {x:mouseX - triWidth, y:mouseY}
    ];
    fakeContext.beginPath();
    if(isOnlyStroke) fakeContext.strokeStyle = brush.color;
    else             fakeContext.fillStyle = brush.color;
    fakeContext.moveTo(threePoint[0].x, threePoint[0].y);
    fakeContext.lineTo(threePoint[1].x, threePoint[1].y);
    fakeContext.lineTo(threePoint[2].x, threePoint[2].y);
    fakeContext.lineTo(threePoint[0].x, threePoint[0].y);
    if(isOnlyStroke) fakeContext.stroke();
    else             fakeContext.fill();
    fakeContext.closePath();
    
    if(isOnlyStroke){
      fakeContext.fillStyle = brush.color;
      for(var i in threePoint){
        fakeContext.beginPath();
        fakeContext.arc(threePoint[i].x, threePoint[i].y, brush.thick/2, 0, 2*Math.PI);
        fakeContext.fill();
        fakeContext.closePath();
      }
    }
  } else if( drawType == 'line' ){
    fakeContext.beginPath();
    if( dragging ){
      fakeContext.arc(lastClickPosition.x, lastClickPosition.y, brush.thick/2, 0, 2.0 * Math.PI, 0);
      fakeContext.arc(mouseX, mouseY, brush.thick/2, 0, 2.0 * Math.PI, 0);
      fakeContext.fillStyle = brush.color;
      fakeContext.fill();
      fakeContext.closePath();
      
      fakeContext.beginPath();
      fakeContext.moveTo(lastClickPosition.x, lastClickPosition.y);
      fakeContext.lineTo(mouseX, mouseY);
      fakeContext.strokeStyle = brush.color;
      fakeContext.stroke();
    } else {
      fakeContext.arc(mouseX, mouseY, brush.thick/2, 0, 2.0 * Math.PI, 0);
      
      fakeContext.fillStyle = brush.color;
      fakeContext.fill();
    }
    fakeContext.closePath();
  } else if( drawType == 'colorPicker' ) {
    fakeContext.beginPath();
    fakeContext.strokeStyle = 'rgba(255, 255, 255, .5)';
    fakeContext.lineWidth = 12;
    fakeContext.arc(mouseX, mouseY, 20, 0, 2.0 * Math.PI, 0);
    fakeContext.stroke();
    if(dragging){
      var img_data = realContext.getImageData(mouseX, mouseY, 1, 1).data;
      var decetedColor = '#'+rgbToHex(img_data[0], img_data[1], img_data[2]);
      fakeContext.fillStyle = decetedColor;
      fakeContext.fill();
      changeColor(decetedColor);
    }
    fakeContext.closePath();
  }
  fakeContext.strokeStyle = oldStrokeStyle;
  fakeContext.fillStyle = oldFillStyle;
  fakeContext.lineWidth = brush.thick;
});

function draw(shape, startPosition, endPosition){
  realContext.strokeStyle = brush.color;
  realContext.fillStyle = brush.color;
  realContext.lineJoin = "round";
  realContext.lineWidth = brush.thick;

  if( !shape || shape == 'brush' ) {
    for(var i=0; i < pointQueue.length; ++i){
      realContext.beginPath();
      if( i-1 >= 0 && pointQueue[i].dragging ){
        realContext.moveTo(pointQueue[i-1].x, pointQueue[i-1].y);
      } else {
        realContext.moveTo(pointQueue[i].x-1, pointQueue[i].y);
      }
      realContext.lineTo(pointQueue[i].x, pointQueue[i].y);
      realContext.closePath();
      realContext.stroke();
    }
  }
  else if( shape == 'rectangle' ) {
    realContext.beginPath();
    realContext.rect(startPosition.x, startPosition.y, endPosition.x - startPosition.x, endPosition.y - startPosition.y);
    realContext.stroke();
    realContext.closePath();
  }
  else if( shape == 'rectangle-filled' ) {
    realContext.beginPath();
    realContext.fillRect(startPosition.x, startPosition.y, endPosition.x - startPosition.x, endPosition.y - startPosition.y);
    realContext.fill();
    realContext.closePath();
  }
  else if( drawType.substr(0, 'circle'.length) == 'circle' ) {
    var isOnlyStroke = drawType === 'circle';
    var centerX = startPosition.x;
    var centerY = startPosition.y;
    function distance(width, height){
      return Math.sqrt(width*width + height*height);
    };
    realContext.beginPath();
    if(isOnlyStroke) realContext.strokeStyle = brush.color;
    else             realContext.fillStyle = brush.color;
    realContext.arc(startPosition.x, startPosition.y, distance(endPosition.x - centerX, endPosition.y - centerY), 0, 2 * Math.PI);
    if(isOnlyStroke) realContext.stroke();
    else             realContext.fill();
    realContext.closePath();
  }
  else if( drawType.substr(0, 'triangle'.length) == 'triangle' ) {
    var triWidth = endPosition.x - startPosition.x;
    var isOnlyStroke = drawType === 'triangle';
    var threePoint = [
      {x:startPosition.x + triWidth/2, y:startPosition.y},
      {x:endPosition.x, y:endPosition.y},
      {x:endPosition.x - triWidth, y:endPosition.y}
    ];
    realContext.beginPath();
    if(isOnlyStroke) realContext.strokeStyle = brush.color;
    else             realContext.fillStyle = brush.color;
    realContext.moveTo(threePoint[0].x, threePoint[0].y);
    realContext.lineTo(threePoint[1].x, threePoint[1].y);
    realContext.lineTo(threePoint[2].x, threePoint[2].y);
    realContext.lineTo(threePoint[0].x, threePoint[0].y);
    if(isOnlyStroke) realContext.stroke();
    else             realContext.fill();
    realContext.closePath();
    
    if(isOnlyStroke){
      for(var i in threePoint){
        realContext.beginPath();
        realContext.arc(threePoint[i].x, threePoint[i].y, brush.thick/2, 0, 2*Math.PI);
        realContext.fill();
        realContext.closePath();
      }
    }
  }
  else if( shape == 'line' ) {
    realContext.arc(startPosition.x, startPosition.y, brush.thick/2, 0, 2.0 * Math.PI, 0);
    realContext.arc(endPosition.x, endPosition.y, brush.thick/2, 0, 2.0 * Math.PI, 0);
    realContext.beginPath();
    realContext.moveTo(startPosition.x, startPosition.y);
    realContext.lineTo(endPosition.x, endPosition.y);
    realContext.closePath();
    realContext.stroke();
  }
}

function addDrawPoint(evt){
  if( drawType == 'brush' ){
    if( dragging ){
      var mouseX = evt.pageX - this.offsetLeft;
      var mouseY = evt.pageY - this.offsetTop;
      pointQueue.push({x: mouseX, y: mouseY, dragging: true});
      draw();
    }
  }
}

function looseFocus(evt){
  dragging = false;
  
  var loosedPosition = {
    x: evt.pageX - this.offsetLeft,
    y: evt.pageY - this.offsetTop
  };
  
  if(evt.type != 'mouseleave'){
    draw(drawType, lastClickPosition, loosedPosition);
  }
  
  cachedImage = realContext.getImageData(0, 0, realContext.canvas.width, realContext.canvas.height);
  pointQueue = [];
  
  realCanvas.removeEventListener('mousemove', addDrawPoint);
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
}

function clearCanvas(){
  pointQueue = [];
  realContext.clearRect(0, 0, realContext.canvas.width, realContext.canvas.height);
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
  cachedImage = realContext.getImageData(0, 0, 1, 1);
}

function changeColor(input){
  brush.color = input;
  document.getElementById('colorPicker').value = input;
}
function setSize(input){
  brush.thick = input.value;
}
function setShape(shape){
  drawType = shape;
}

function rgbToHex(R,G,B) {return toHex(R)+toHex(G)+toHex(B)}
function toHex(n) {
  n = parseInt(n,10);
  if (isNaN(n)) return "00";
  n = Math.max(0,Math.min(n,255));
  return "0123456789ABCDEF".charAt((n-n%16)/16)  + "0123456789ABCDEF".charAt(n%16);
}

function exportImageToPng() {
  var d = realCanvas.toDataURL("image/png");
  var w = window.open('about:blank','image from canvas');
  w.document.write("<img src='"+d+"' alt='from canvas'/>");
}
</script>
</html>