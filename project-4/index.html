<!doctype html>
<html>
<head>
  <title>Paint</title>
  <link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
  <div class="container">
    <nav class="left menu">
      <label>Brush Size</label>
      <input type="number" class="input-control fluid" value="10" onchange="setSize(this)"/>
      
      <hr>
      
      <label>Change Color</label>
      <input type="color" class="input-control fluid" value="#000000" onchange="changeColor(this.value)" style="height: 30px"/>
      
      <button class="color-sample" style="background:#CF000F" onclick="changeColor('#CF000F')">MONZA</button>
      <button class="color-sample" style="background:#22A7F0" onclick="changeColor('#22A7F0')">PICTON BLUE</button>
      <button class="color-sample" style="background:#F7CA18" onclick="changeColor('#F7CA18')">RIPE LEMON</button>
      <button class="color-sample" style="background:#26C281" onclick="changeColor('#26C281')">JUNGLE GREEN</button>
      <button class="color-sample" style="background:#FFFFFF" onclick="changeColor('#FFFFFF')">WHITE</button>
      <hr>
      
      <input type="button" class="input-control fluid" value="clear" onclick="clearCanvas()"/>
    </nav>
    <div class="wrapper">
      <canvas id="cover"  width="860" height="640"></canvas>
      <canvas id="canvas" width="860" height="640"></canvas>
    </div>
  </div>
  <p> &nbsp;<b>Note:</b> type="color" is not supported in Internet Explorer 11 and earlier versions or Safari 9.1 and earlier versions.</p>
</body>
<script type="text/javascript">

// 실제 그림이 그려지는 캔버스
var realCanvas = document.getElementById('canvas');
var realContext = realCanvas.getContext('2d');
// 인터페이스를 위한 임시 캔버스
var fakeCanvas = document.getElementById('cover');
var fakeContext = fakeCanvas.getContext('2d');

function Point(x, y, rad){
  this.x = x;
  this.y = y;
  this.rad = rad;
  this.color = '#000000';
};

var dragging = false;
var pointQueue = new Array();
var brush = {
  color: '#000000',
  thick: 10,
  opacity: 1.0
};
var drawType = 'brush';
var lastClickPosition = { x:0, y:0 };

var cachedImage = realContext.getImageData(0, 0, 1, 1);

fakeCanvas.addEventListener('mousedown', function(evt){
  lastClickPosition.x = evt.pageX - this.offsetLeft;
  lastClickPosition.y = evt.pageY - this.offsetTop;
  
  if( drawType == 'brush' ){
    pointQueue.push({x: lastClickPosition.x, y: lastClickPosition.y, dragging: false});
  }
  dragging = true;
  
  realContext.clearRect(0, 0, realContext.canvas.width, realContext.canvas.height); // Clears the canvas
  realContext.putImageData(cachedImage, 0, 0);

  fakeCanvas.addEventListener('mousemove', addDrawPoint);
  
  if( drawType == 'colorPicker' ){
    var img_data = realContext.getImageData(lastClickPosition.x, lastClickPosition.y, 1, 1).data;
    console.log(rgbToHex(img_data[0], img_data[1], img_data[2]));
  }

  draw();
});

fakeCanvas.addEventListener('mouseup', looseFocus);
fakeCanvas.addEventListener('mouseleave', looseFocus);
fakeCanvas.addEventListener('mousemove', function(evt){
  var mouseX = evt.pageX - this.offsetLeft;
  var mouseY = evt.pageY - this.offsetTop;
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
  fakeContext.beginPath();
  if( drawType == 'brush' ){
    fakeContext.arc(mouseX, mouseY, brush.thick/2, 0, 2*Math.PI);
    if(brush.color == '#FFFFFF'){
      fakeContext.strokeStyle = 'rgba(0, 0, 0, .25)';
      fakeContext.stroke();
    }
  } else if( drawType == 'rectangle' && dragging ){
    fakeContext.fillRect(lastClickPosition.x, lastClickPosition.y, mouseX - lastClickPosition.x, mouseY - lastClickPosition.y);
  }
  fakeContext.fillStyle = brush.color;
  fakeContext.fill();
  fakeContext.closePath();
});

function draw(shape, startPosition, endPosition){
  realContext.strokeStyle = brush.color;
  realContext.fillStyle = brush.color;
  realContext.lineJoin = "round";
  realContext.lineWidth = brush.thick;
  
  
  if( !shape || shape == 'brush' )
  {
    for(var i=0; i < pointQueue.length; ++i){
      realContext.beginPath();
      if( i-1 >= 0 && pointQueue[i].dragging ){
        realContext.moveTo(pointQueue[i-1].x, pointQueue[i-1].y);
      } else {
        realContext.moveTo(pointQueue[i].x-1, pointQueue[i].y);
      }
      realContext.lineTo(pointQueue[i].x, pointQueue[i].y);
      realContext.closePath();
      realContext.stroke();
    }
  }
  else if( shape == 'rectangle' ) {
    realContext.beginPath();
    realContext.fillRect(startPosition.x, startPosition.y, endPosition.x - startPosition.x, endPosition.y - startPosition.y);
    realContext.fill();
    realContext.closePath();
  }
}

function addDrawPoint(evt){
  if( drawType == 'brush' ){
    if( dragging ){
      var mouseX = evt.pageX - this.offsetLeft;
      var mouseY = evt.pageY - this.offsetTop;
      pointQueue.push({x: mouseX, y: mouseY, dragging: true});
      draw();
    }
  } else if( drawType == 'rectangle' ){
    
  }
}

function looseFocus(evt){
  dragging = false;
  
  var loosedPosition = {
    x: evt.pageX - this.offsetLeft,
    y: evt.pageY - this.offsetTop
  };
  
  if(evt.type != 'mouseleave') draw(drawType, lastClickPosition, loosedPosition);
  
  cachedImage = realContext.getImageData(0, 0, realContext.canvas.width, realContext.canvas.height);
  pointQueue = [];
  
  realCanvas.removeEventListener('mousemove', addDrawPoint);
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
}

function clearCanvas(){
  pointQueue = [];
  realContext.clearRect(0, 0, realContext.canvas.width, realContext.canvas.height);
  fakeContext.clearRect(0, 0, fakeContext.canvas.width, fakeContext.canvas.height);
  cachedImage = realContext.getImageData(0, 0, 1, 1);
}

function changeColor(input){
  brush.color = input;
}
function setSize(input){
  brush.thick = input.value;
}

function rgbToHex(R,G,B) {return toHex(R)+toHex(G)+toHex(B)}
function toHex(n) {
  n = parseInt(n,10);
  if (isNaN(n)) return "00";
  n = Math.max(0,Math.min(n,255));
  return "0123456789ABCDEF".charAt((n-n%16)/16)  + "0123456789ABCDEF".charAt(n%16);
}
	
</script>
</html>